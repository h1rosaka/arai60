# 問題タイトル
問題リンク
- https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/


# STEP 1 自力で解く。
1回目間違えた 7m55s
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        current_value = node.val

        while node is not None and node.next is not None:
            if node.next.val == current_value:
                node.next = node.next.next
            else:
                node = node.next
        return head
```

current_valueの更新を忘れていたので追記し、Runはacceptされたが、submitすると```current_value = node.val```のところで``` 'NoneType' object has no attribute 'val'``` エラー

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        current_value = node.val

        while node is not None and node.next is not None:
            if node.next.val == current_value:
                node.next = node.next.next
            else:
                node = node.next
                current_value = node.val
                
        return head

```
確かに```node = node.next```した時点で、nodeがNoneになってるかもしれないので、Noneチェックした後にcurrent_valueを更新するようにする
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        current_value = node.val

        while node is not None and node.next is not None:
            current_value = node.val

            if node.next.val == current_value:
                node.next = node.next.next
            else:
                node = node.next
                    
        return head

```
今度は、whileの外の最初の```current_value = node.val```でエラー。確かにheadの時点からvalがNoneのもの渡されることを考慮できてなかった。そもそもwhileの外でこの処理を実施する必要ないので除いた。今度は正解できた。
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head

        while node is not None and node.next is not None:
            current_value = node.val

            if node.next.val == current_value:
                node.next = node.next.next
            else:
                node = node.next
                    
        return head
```

- コメント
    - テストケースを頭で通すのをサボったので、current_valueの更新を忘れた。サボらずやる。
    - 連結リストを渡すと言いながら、headがNoneなのはよくある落とし穴?っぽいので、連結リストを扱うときは気をつける


- 所要時間
    - 7m55s(間違えたが)
- 計算量
    - 時間
        - O(N)
            - ノードを一つずつ最後まで確認するので。
    - 空間
        - O(1)
            - 全てのノードの値を覚える必要はなく、毎回の処理でそのとき必要なものだけ記憶するので。

# STEP2 読みやすくする＆他の人の解法を見る
### 2_1.  正解を見てみる
https://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/5189831/video-explain-important-points/
``` py
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        res = head

        while head and head.next:
            if head.val == head.next.val:
                head.next = head.next.next
            else:
                head = head.next
        
        return res
```

- 計算量
    - 時間
        - O(n)
    - 空間
        - O(1)
- コメント
    - 大体一緒だが、私と違ってcurrent_valueに相当するものを別の変数として切りだしていなかった。改めて考えると、確かになくても問題なかった。
    - pep8の記載をNoneとの比較はいつもisで、と理解したのでそう書いているが、```is not None``` が2回出てくると長ったらしくてleetcodeの正解の書き方の方がスマートに見える。isを使う書き方のままで良いのだろうか。
        >Comparisons to singletons like None should always be done with is or is not, never the equality operators.
        Also, beware of writing if x when you really mean if x is not None – e.g. when testing whether a variable or argument that defaults to None was set to some other value. The other value might have a type (such as a container) that could be false in a boolean context!
     - https://peps.python.org/pep-0008/#programming-recommendations


### 2_2. 他の人の解法1
-  https://github.com/goto-untrapped/Arai60/pull/42/files
    - 元のコードはjavaだったのでchatGPTにpythonに書き直してもらった。
    ```py
    class RemoveDuplicatesFromSortedList:
        def delete_duplicates(self, head: ListNode) -> ListNode:
            if head is None:
                return head
            
            # 新しいリストの最初のノードを作成
            unique = ListNode(head.val)
            node = unique
            next_node = head.next
            
            while next_node is not None:
                if next_node.val == node.val:
                    next_node = next_node.next
                    continue
                
                node.next = ListNode(next_node.val)
                node = node.next
                next_node = next_node.next
            
            return unique
    ```
- 先にheadがnullだった場合に、early returnしちゃうの裏技っぽくて賢くて良いな。私もよくheadが空だった時の考慮忘れて後から既に作ったロジックの順番入れ替えたりするので、この技は覚えておきたい。
- if elseよりもif cnotinueと後続処理、と書いた方がifに合致した時に、if elseの後に何かあるかも、と心配をせず、心置きなくループの先頭に戻れて頭が楽かもしれない。いろんな書き方があるな。
- 再帰でも書いている。連結リストは一個ずつ調べていくことが多いので、大体再帰でも書けるようになっているのかもしれない。自分でも再帰で解いてみる。
    ```py
    class Solution:
        def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
            if head is None:
                return None

            self._check_node(head)

            return head


        def _check_node(self, node:Optional[ListNode]) -> ListNode:
            if node.next is None:
                return

            if node.val == node.next.val:
                node.next = node.next.next
            else:
                node = node.next

            return self._check_node(node)
    ```
- 何度かエラーになりながらも、書くことができた。まだ再帰は慣れない。参考にしてるPRでは複数の方法で再帰していたので確認する。

# STEP3　　3回連続でエラーなしで解けるまで解く

# STEP4 レビューFB反映