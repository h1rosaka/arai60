# 問題タイトル
問題リンク
- https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/


# STEP 1 自力で解く。
1回目間違えた 7m55s
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        current_value = node.val

        while node is not None and node.next is not None:
            if node.next.val == current_value:
                node.next = node.next.next
            else:
                node = node.next
        return head
```

current_valueの更新を忘れていたので追記し、Runはacceptされたが、submitすると```current_value = node.val```のところで``` 'NoneType' object has no attribute 'val'``` エラー

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        current_value = node.val

        while node is not None and node.next is not None:
            if node.next.val == current_value:
                node.next = node.next.next
            else:
                node = node.next
                current_value = node.val
                
        return head

```
確かに```node = node.next```した時点で、nodeがNoneになってるかもしれないので、Noneチェックした後にcurrent_valueを更新するようにする
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        current_value = node.val

        while node is not None and node.next is not None:
            current_value = node.val

            if node.next.val == current_value:
                node.next = node.next.next
            else:
                node = node.next
                    
        return head

```
今度は、whileの外の最初の```current_value = node.val```でエラー。確かにheadの時点からvalがNoneのもの渡されることを考慮できてなかった。そもそもwhileの外でこの処理を実施する必要ないので除いた。今度は正解できた。
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head

        while node is not None and node.next is not None:
            current_value = node.val

            if node.next.val == current_value:
                node.next = node.next.next
            else:
                node = node.next
                    
        return head
```

- コメント
    - テストケースを頭で通すのをサボったので、current_valueの更新を忘れた。サボらずやる。
    - 連結リストを渡すと言いながら、headがNoneなのはよくある落とし穴?っぽいので、連結リストを扱うときは気をつける


- 所要時間
    - 7m55s(間違えたが)
- 計算量
    - 時間
        - O(N)
            - ノードを一つずつ最後まで確認するので。
    - 空間
        - O(1)
            - 全てのノードの値を覚える必要はなく、毎回の処理でそのとき必要なものだけ記憶するので。

# STEP2 読みやすくする＆他の人の解法を見る
### 2_1.  正解を見てみる
https://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/5189831/video-explain-important-points/
``` py
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        res = head

        while head and head.next:
            if head.val == head.next.val:
                head.next = head.next.next
            else:
                head = head.next
        
        return res
```

- 計算量
    - 時間
        - O(n)
    - 空間
        - O(1)
- コメント
    - 大体一緒だが、私と違ってcurrent_valueに相当するものを別の変数として切りだしていなかった。改めて考えると、確かになくても問題なかった。
    - pep8の記載をNoneとの比較はいつもisで、と理解したのでそう書いているが、```is not None``` が2回出てくると長ったらしくてleetcodeの正解の書き方の方がスマートに見える。isを使う書き方のままで良いのだろうか。
        >Comparisons to singletons like None should always be done with is or is not, never the equality operators.
        Also, beware of writing if x when you really mean if x is not None – e.g. when testing whether a variable or argument that defaults to None was set to some other value. The other value might have a type (such as a container) that could be false in a boolean context!
     - https://peps.python.org/pep-0008/#programming-recommendations


### 2_2. 他の人の解法
-  https://github.com/goto-untrapped/Arai60/pull/42/files

### 2_2_a. 再帰ではない方
    - 元のコードはjavaだったのでchatGPTにpythonに書き直してもらった。
    ```py
    class RemoveDuplicatesFromSortedList:
        def delete_duplicates(self, head: ListNode) -> ListNode:
            if head is None:
                return head
            
            # 新しいリストの最初のノードを作成
            unique = ListNode(head.val)
            node = unique
            next_node = head.next
            
            while next_node is not None:
                if next_node.val == node.val:
                    next_node = next_node.next
                    continue
                
                node.next = ListNode(next_node.val)
                node = node.next
                next_node = next_node.next
            
            return unique
    ```
- 先にheadがnullだった場合に、early returnしちゃうの裏技っぽくて賢くて良いな。私もよくheadが空だった時の考慮忘れて後から既に作ったロジックの順番入れ替えたりするので、この技は覚えておきたい。
- if elseよりもif cnotinueと後続処理、と書いた方がifに合致した時に、if elseの後に何かあるかも、と心配をせず、心置きなくループの先頭に戻れて頭が楽かもしれない。いろんな書き方があるな。





- https://discord.com/channels/1084280443945353267/1195700948786491403/1196399353116499970
    ```py
    curr = head
    while curr:
        while curr.next and curr.val ==  curr.next.val:
            curr.next = curr.next.next
        curr = curr.next
    return head
    ```
    - if　~ continueでループ回すなら、whileの方が一言で済むのでシンプルで良さそう。
    - ```while curr```が一つ外出ししてあるから、``` curr.next = curr.next.next ``` が終わった後に次の回で判断する必要があるロジックが2つだけで済んでる。自分の元のは考える必要のないロジックも毎回の繰り返しの中で考えさせて無駄な負担をかけていた。


- https://github.com/sakupan102/arai60-practice/pull/3#discussion_r1560774058
    - > ループと再帰は、同じ内容を書くのであれば、ループのほうが読むにあたり認知負荷が低いようです。
        https://twitter.com/nodchip/status/1765579286646530148
        個人的にもループで書いたほうが認知負荷が低いように感じます。

        ただし、所属するチーム内で再帰で書く人のほうが多い場合、そちらで書いたほうが良いと思います。
        - ちょっと読み解くの大変だなと思っていたが、他の人もそうらしく安心した。再帰は読みづらいしスタックオーバーフローも気をつける必要あるしで使いにくいなと思ったので、逆にどんな良いところがあるのか聞いてみた。
            -   再帰関数にはいくつかの重要なメリットがあります。以下にその主な利点を挙げます。

                ## 問題の分割

                再帰関数は、複雑な問題をより小さな部分問題に分解するのに適しています。このアプローチにより、問題をシンプルな形に整理し、解決しやすくします。特に、再帰的な性質を持つ問題やデータ構造（例えば、ツリーやグラフの操作）において効果的です[2][5]。

                ## コードの簡潔さ

                再帰を使用することで、特定のアルゴリズムをより簡潔に表現できることがあります。例えば、階乗やフィボナッチ数列を計算する際、再帰的な実装はループを用いた場合よりも直感的で読みやすい場合があります[2][4]。

                ## 自然な表現

                数学的な問題やアルゴリズムの自然な表現が可能です。再帰的なアプローチは、数学的な定義に基づくため、プログラムがより理解しやすくなることがあります[2][3]。

                ## メモ化との組み合わせ

                再帰関数は、メモ化（計算結果を保存して再利用する技術）と組み合わせることで、計算効率を大幅に向上させることができます。これにより、同じ計算を繰り返す必要がなくなり、特に指数的な計算を要する問題においてパフォーマンスが改善されます[1]。

                ## まとめ

                再帰関数は、問題の分割、コードの簡潔さ、自然な表現、メモ化との組み合わせによる効率化など、多くのメリットを提供します。ただし、基底ケースが適切に設定されていない場合や、スタックオーバーフローのリスクがあるため、使用には注意が必要です[2][4][5]。

                Citations:
                [1] https://qiita.com/drken/items/23a4f604fa3f505dd5ad
                [2] https://zenn.dev/collabostyle/articles/358dfed7e70fac
                [3] https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q10160694495
                [4] https://oshiete.goo.ne.jp/qa/3698771.html
                [5] https://wosugi.hatenablog.com/entry/20090721/1249097807


- 再帰ではない方法でのSTEP2
```py

class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head

        while node is not None:
            while node.next is not None and node.next.val == node.val:
                node.next = node.next.next
                
            node = node.next
                    
        return head

```







### 2_2_b. 再帰


- 再帰でも書いている。連結リストは一個ずつ調べていくことが多いので、大体再帰でも書けるようになっているのかもしれない。自分でも再帰で解いてみる。
    ```py
    class Solution:
        def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
            if head is None:
                return None

            self._check_node(head)

            return head


        def _check_node(self, node:Optional[ListNode]) -> ListNode:
            if node.next is None:
                return

            if node.val == node.next.val:
                node.next = node.next.next
            else:
                node = node.next

            return self._check_node(node)
    ```
- 何度かエラーになりながらも、書くことができた。まだ再帰は慣れない。参考にしてるPRでは複数の方法で再帰していたので確認する。
- [元の実装](https://github.com/goto-untrapped/Arai60/pull/42/files#diff-955136daee65dfdfb0d127b8407c9efa23cc6cb7260f7fdbfc6c4ea1d95b990eR59-R78)をpythonにしたもの。↓
```py
class Solution:

    def _deleteDuplicatesHelper(self, node):
        if node is None:
            return node
        
        following_node = self._deleteDuplicatesHelper(node.next)
        
        if following_node is None:
            return node
        
        if node.val == following_node.val:
            node.next = node.next.next
        
        return node

    def deleteDuplicates(self, head):
        return self._deleteDuplicatesHelper(head)

```
- 一方向の連結リストなのに、戻りながら処理してる。すごい。こんなことできるのか。


# STEP3　　3回連続でエラーなしで解けるまで解く
- 今回は一発で解けなかったので、再帰ではない方を練習する。
- 連結リストで個人的に気をつけることまとめ
    - headがNoneのもの渡されても大丈夫か
    - .valや.nextがついてるものがNoneになって参照できないことがないか
```py
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head

        while node is not None:
            while node.next is not None and node.next.val == node.val:
                node.next = node.next.next
            node = node.next
            
        return head


```

# STEP4 レビューFB反映