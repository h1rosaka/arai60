# 問題タイトル
問題リンク
- https://leetcode.com/problems/add-two-numbers/description/

> You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.


# STEP 1 自力で解く。
```py
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy_head = ListNode(-1)
        tail = dummy_head

        total = 0

        node = l1
        digit = 1
        while node:
            total += node.val * (10 ** (digit-1))
            digit += 1
            node = node.next

        node = l2
        digit = 1
        while node:
            total += node.val * (10 ** (digit-1))
            digit += 1
            node = node.next

        stringified_total = str(total)

        for i in range(len(stringified_total), 0, -1):
            value = stringified_total[i-1]
            tail.next = ListNode(value)
            tail = tail.next

        return dummy_head.next

```
- 所要時間
    - 15min
- 計算量
    - 時間: O(N)
        - total出す処理は、l1の長さとl2の長さ分だけ。その後答えを作るのにまた答えの桁数だけ。
    - 空間: O(1)
        - l1やl2が長くとも、処理中に覚えておかなければならないものの数は増えない。
- コメント
    - 素直に合計の数字を計算して、それを元に答えとなるLinkedListを作成した。
    - 正解できたのは良いが、繰り返しの処理は共通化したいな。
    - stringified_totalに対して、reverseやreversedをかけても良かったかも。
        →文字列はイミュータブルなので、元のオブジェクトを変えるreverse()は実装されておらず、組み込み関数のreversed()が使えるだけだった。

# STEP2 読みやすくする＆他の人の解法を見る
### 2_1.  正解を見てみる
https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/

- <details><summary>コード</summary>
    ```py
    class Solution:
        def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
            dummyHead = ListNode(0)
            tail = dummyHead
            carry = 0

            while l1 is not None or l2 is not None or carry != 0:
                digit1 = l1.val if l1 is not None else 0
                digit2 = l2.val if l2 is not None else 0

                sum = digit1 + digit2 + carry
                digit = sum % 10
                carry = sum // 10

                newNode = ListNode(digit)
                tail.next = newNode
                tail = tail.next

                l1 = l1.next if l1 is not None else None
                l2 = l2.next if l2 is not None else None

            result = dummyHead.next
            dummyHead.next = None
            return result
    ```
</details>

 - コメント
     - 一気に合計を計算するのではなく、一桁ずつ繰り上がりを気にしながら正解の数字(合計のある桁の数字)を出している
     - digitという単語を使って、0-9の数字を表している。(私は桁数/位という意味でdigitを使っていた)
     - digitの意味を勘違いしていた。
     - 桁数、や位という概念ではなく、ただ0-9の数字という意味らしい。
     - つまり、2 digits number は2桁の数(十の位と1の位がある数)というより、2つの数字からなる数という意味っぽい？
        - > any one of the numbers 0 through 9:
        - https://dictionary.cambridge.org/ja/dictionary/english/digit
        - https://www.mathsisfun.com/definitions/digit.html
    - ちなみに桁、というのはそろばんの縦の棒のことらしい。
    - では、結局私が最初に書いたコードのdigitはどういう名前に変えたら良いのだろうか。。
    - [10のくらいはtens placeらしい](https://eikaiwa.dmm.com/uknow/questions/56442/)ので、place?

### 2-2. 他の方の解法

 [1つ目](https://github.com/ask-1407/leetcode/pull/7)

- leetcodeの正解と大体同じものが一つと、再帰で解いている方法が一つ。

    <details><summary>再帰のコード</summary>
    ``` py 
    class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode],carry = 0) -> Optional[ListNode]:
        if not l1 and not l2 and not carry:
            return None

        l1_val = l1.val if l1 else 0
        l2_val = l2.val if l2 else 0
        total = carry + l1_val + l2_val
        carry = total // 10
        current_node = ListNode(total % 10)

        l1_next = l1.next if l1 else None
        l2_next = l2.next if l2 else None
        current_node.next = self.addTwoNumbers(l1_next, l2_next, carry)

        return current_node
    ```
    </details>

- 今まで見てきた再帰は、ヘルパー関数？を使っていたが、これはaddTwoNumbers自体を再帰関数にしている。ヘルパー関数は使う方が良いとか使わない方が良いとかあるのだろうか。


[2つ目](https://github.com/Mike0121/LeetCode/pull/41/files)
- <details><summary>疑問点のあるstep3の再帰のコード</summary>

    ```py
    class Solution:
        def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
            def get_value(node: Optional[ListNode]) -> int:
                if node is None:
                    return 0
                return node.val

            def next_node(node: Optional[ListNode]) -> Optional[ListNode]:
                if node is None:
                    return None
                return node.next

            def _add_two_numbers_helper(node1: Optional[ListNode] , node2: Optional[ListNode], carry: int) -> Optional[ListNode]:
                if not (node1 or node2 or carry):
                    return None
                
                value1 = get_value(node1)
                value2 = get_value(node2)
                total = value1 + value2 + carry
                node = ListNode(total % 10)
                carry = total // 10
                node.next = _add_two_numbers_helper(next_node(node1), next_node(node2), carry)
                return node

            return _add_two_numbers_helper(l1, l2, 0)

    ```

    </details>



- 疑問1:_add_two_numbers_helperや、get_value, next_nodeの引数にselfが入っていない。しかしエラーになるわけでもなく、leetcode上では正解となる。メソッドにselfは必須かと思っていたがそうではないのか？
    - メソッドはあくまで、クラス定義から一つインデント降りたところにあるdefのものだけなので、addTwoNumbersだけがメソッドで、他のものはメソッド内で定義した関数であってメソッドではないので、selfを引数に取る必要はない?
    

- 疑問2:_add_two_numbers_helper, get_value, next_nodeの3つのメソッドのうち、一つだけアンダースコアから始まっている。なぜ一つだけ？
    - そもそもアンダースコアは、メソッドhogeが外からSolution.hoge()のように呼ばれないために、_hoge()とつける慣習。今回はそもそも3つとも全てはメソッドではないから、実はつける必要ない？それとも何か他の理由があってつけている？



- STEP2完成版その１(再帰)
    - Mike0121 san のものをベースに、末尾再帰にして、三項演算子も活用。
        ```py
        class Solution:
            def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
                dummy_head = ListNode(-1)

                def get_value(node: Optional[ListNode]) -> int:
                    return 0 if node is None else node.val

                def next_node(node: Optional[ListNode]) -> Optional[ListNode]:
                    return None if node is None else node.next

                def add_two_numbers_helper(node1: Optional[ListNode] , node2: Optional[ListNode], carry: int, node) -> Optional[ListNode]:
                    if not (node1 or node2 or carry):
                        return None
                    
                    value1 = get_value(node1)
                    value2 = get_value(node2)
                    total = value1 + value2 + carry

                    new_node = ListNode(total % 10)
                    node.next = new_node

                    carry = total // 10

                    return add_two_numbers_helper(next_node(node1), next_node(node2), carry, new_node)

                add_two_numbers_helper(l1, l2, 0, dummy_head)

                return dummy_head.next

        ```

- STEP2完成版その2
    - 自分のSTEP1を綺麗にしたもの
        ```py
        def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
            dummy_head = ListNode(-1)
            tail = dummy_head

            def sum_all_node_vals(base: int, head: Optional[ListNode])->int:
                total = base
                node = head
                digit_position = 0
                while node:
                    total += node.val * (10**digit_position)
                    node = node.next
                    digit_position += 1
                return total

            total = sum_all_node_vals(0, l1)
            total = sum_all_node_vals(total, l2)

            for digit in reversed(str(total)):
                tail.next = ListNode(int(digit))
                tail = tail.next
            
            return dummy_head.next

        ```

# STEP3　　3回連続でエラーなしで解けるまで解く
STEP2完成版その2と同じ。
```py
def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    dummy_head = ListNode(-1)
    tail = dummy_head

    def sum_all_node_vals(base: int, head: Optional[ListNode])->int:
        total = base
        node = head
        digit_position = 0
        while node:
            total += node.val * (10**digit_position)
            node = node.next
            digit_position += 1
        return total

    total = sum_all_node_vals(0, l1)
    total = sum_all_node_vals(total, l2)

    for digit in reversed(str(total)):
        tail.next = ListNode(int(digit))
        tail = tail.next
    
    return dummy_head.next

```



# STEP4 レビューFB反映