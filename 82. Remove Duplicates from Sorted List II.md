# 82. Remove Duplicates from Sorted List II
https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/
>Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.



# STEP 1 自力で解く。

16mかけて下記を書いてWAだった。
 - <details><summary>コード</summary>

    ```py
    # Definition for singly-linked list.
    # class ListNode:
    #     def __init__(self, val=0, next=None):
    #         self.val = val
    #         self.next = next
    class Solution:
        def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
            node = head
            # 1.同じ値のnodeは一つしか連続しない状態にする
            deleted_vals = set()
            while node is not None:
                while node.next is not None and node.next.val== node.val:
                    node.next = node.next.next
                    deleted_vals.add(node.val)
                node = node.next
            #2.1で除いたvalと同じvalのnodeは改めて除く
            if head.val in deleted_vals:
                head = head.next
            
            node2 = head
            while node2 is not None:
                if node2.next is not None and node2.next.val in deleted_vals:
                    node2.next = node2.next.next
                node2 = node2.next
            
            return head
    ```
    </details>

- コード内の"2"で、自身の次が削除対象か、と言うのをみていたが、それだと自身が削除対象かどうかを判断しないので、すり抜けるパターン(連続で削除対象の数字が続く)がある

その後何度かエラーを出しながら下記を書いたが、Time Limit Exceeded
 - <details><summary>コード</summary>

    ```py
    class Solution:

        def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
            node = head
            # 1.同じ値のnodeは一つしか連続しない状態にする
            deleted_vals = set()
            while node is not None:
                while node.next is not None and node.next.val== node.val:
                    node.next = node.next.next
                    deleted_vals.add(node.val)
                node = node.next
            #2.1で除いたvalと同じvalのnodeは改めて除く
            if head.val in deleted_vals:
                head = head.next
            node2 = head
            while node2 is not None:
                node2.next = self._find_first_ok_node_after_this(node2, deleted_vals)
                node2 = node2.next
            
            return head

        def _find_first_ok_node_after_this(self, node, deleted_vals):
            if node not in deleted_vals: 
                return node
            return self._find_ok_node_after_this(node.next)

    ```
</details>

- 時間のかかっている箇所を特定するために時間計算量を考える
    -  1.同じ値のnodeは一つしか連続しない状態にする
        - O(N)
    - 2.1で除いたvalと同じvalのnodeは改めて除く
        - O(N^2)
            - whileループがO(N)
            - whileの中で呼ぶ_find_first_ok_node_after_this()がO(N)

- whileループの中で再帰を呼ぶと計算量が多くなって筋が悪そうなので最初の解法を見直して、最終的に下記でAcceptされた
```
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        # 1.同じ値のnodeは一つしか連続しない状態にする
        deleted_vals = set()
        while node is not None:
            while node.next is not None and node.next.val== node.val:
                node.next = node.next.next
                deleted_vals.add(node.val)
            node = node.next

        #2.1で除いたvalと同じvalのnodeは改めて除く
        while head is not None and head.val in deleted_vals:
            head = head.next
        
        node2 = head
        while node2 is not None:
            while node2.next is not None and node2.next.val in deleted_vals:
                node2.next = node2.next.next
            node2 = node2.next
        
        return head

```
- 元々失敗していたパターンがどう言うパターンか言語化しておらず、「連続で削除対象の数字が続く」パターンだと言語化したら、ifをwhileに変えることで直せることに気づいた。
- 計算量
    - 時間
        - O(N)
    - 空間
        - O(N)
            - 11223344...みたいに二個ずつ並ぶと、N/2個の要素をdeleted_valsとして記憶しておく必要がある

# STEP2 読みやすくする＆他の人の解法を見る
### 2_1.  正解を見てみる
- https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/2419088/very-easy-100-fully-explained-java-c-python-js-c-python3/
- <details><summary>コード</summary>

    ```py
    class Solution(object):
        def deleteDuplicates(self, head):
            fake = ListNode(-1)
            fake.next = head
            # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...
            curr, prev = head, fake
            while curr:
                # while we have curr.next and its value is equal to curr...
                # It means, that we have one more duplicate...
                while curr.next and curr.val == curr.next.val:
                    # So move curr pointer to the right...
                    curr = curr.next
                # If it happens, that prev.next equal to curr...
                # It means, that we have only 1 element in the group of duplicated elements...
                if prev.next == curr:
                    # Don't need to delete it, we move both pointers to right...
                    prev = prev.next
                    curr = curr.next
                # Otherwise, we need to skip a group of duplicated elements...
                # set prev.next = curr.next, and curr = prev.next...
                else:
                    prev.next = curr.next
                    curr = prev.next
            # Return the linked list...
            return fake.next
    ```
    </details>
- コメント
    - 作業者を二人用意して、二人の間をカットしたりしてうまいこと不要なものを除いている。(curr, prevが作業者)
    - 私が解こうとしていた時は、作業者を一人しか用意しないでなんとかしようとしていたが、この解法のように2人用意して動かせばスムーズになることがあるのだな、と学んだ。

### 2_2.  別の方の解法
- https://github.com/goto-untrapped/Arai60/pull/43/files
    - <details><summary>step4をpythonにしたコード</summary>

        ```py
        class Solution:
            def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
                dummy_head = ListNode()
                dummy_head.next = head
                node = dummy_head

                while node and node.next and node.next.next:
                    # 次の値と、さらにその次の値が異なるなら、nodeを次へ移す
                    if node.next.val != node.next.next.val:
                        node = node.next
                        continue
                    # 次の値と、さらにその次の値が同じ場合、その値をvalueとする
                    # valueと違う値になるまで、node.nextを一つずつ先のものへ。
                    value = node.next.val
                    while node.next and node.next.val == value:
                        node.next = node.next.next

                return dummy_head.next

        ```
        </details>
    - 作業者は一人だけど、headの前にdummyheadを置くことで、今注目してるnodeより前のものに対して作業して、いらないものを外す、ということを実現している。
- https://discord.com/channels/1084280443945353267/1183683738635346001/1183691370683174973
    - <details><summary>chatGPTがpythonにしたコード</summary>

        ```py
        def delete_duplicates(head: ListNode) -> ListNode:
        if not head:
            return None

        # 新しいリストのダミーヘッドを作成
        dummy = ListNode()
        tail = dummy
        current = head
        count = 0

        while current:
            # 重複カウントを増加
            count = 1
            while current.next and current.val == current.next.val:
                current = current.next
                count += 1
            
            # 重複がない場合のみノードを追加
            if count == 1:
                tail.next = current
                tail = tail.next
            
            # 次のノードへ移動
            current = current.next
        
        # 最後のノードの次をNoneに設定
        tail.next = None
        
        return dummy.next
        ```
    </details>
    
    - こちらも作業者は一人だが、別の新たなLinkedListを用意して、そちらに必要なものだけ付け足していっている(既存のLinkedeListから除くのではなく)

    - 元のコードとちょっと雰囲気違うのでChatGPTが何か変換ミスってるかもしれないがC++の知識がないのでわからない。一旦深追いはせず、他の解法を見る。
- https://github.com/YukiMichishita/LeetCode/pull/1
    - <details><summary>コード</summary>

        ```py
        class Solution:
            def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
                dummy = ListNode()
                last_unique_node = dummy
                current = head
                val_to_remove = None

                while current:
                    if current.val == val_to_remove:
                        current = current.next
                        continue
                    if current.next and current.val == current.next.val:
                        val_to_remove = current.val
                        continue
                    last_unique_node.next = ListNode(current.val)
                    last_unique_node = last_unique_node.next
                    current = current.next

                return dummy.next
        ```
        </details>
    - 作業者一人。別の新たな列作って、さらにそこに連結するノードも毎度新規のインスタンス作って足してる。

- https://discord.com/channels/1084280443945353267/1195700948786491403/1196701558382018590

- 




# STEP3　　3回連続でエラーなしで解けるまで解く
<details><summary>pythonにしたコード</summary>
```py
```
</details>


# STEP4 レビューFB反映